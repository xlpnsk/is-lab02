import Head from "next/head";
import { Roboto } from "next/font/google";
import styles from "@/styles/Home.module.css";
import * as React from "react";
import { downloadTxt, joinDataTable, mapTxt } from "@/utlis/txt";
import { ICell, IXMLParsedData } from "@/types/globals";
import { validateCell, validateTxtFileFormat } from "@/utlis/validator";
import { headers } from "@/utlis/headers";
import { XMLParser } from "fast-xml-parser";
import { handleXmlSave, parseXmlToCellData } from "@/utlis/xml";
import { Row } from "@/components/Row";
import {
  compareWithDb,
  findDuplicates,
  getDbData,
  parseDbData,
  saveDbData,
} from "@/utlis/db";

const roboto = Roboto({
  subsets: ["latin"],
  weight: ["100", "300", "400", "500", "700", "900"],
});

export default function Home() {
  const [file, setFile] = React.useState<File>();
  const [tableArray, setTableArray] = React.useState<ICell[][]>([]);
  const [currentDbState, setCurrentDbState] = React.useState<ICell[][]>([]);
  const [error, setError] = React.useState<string | null>(null);

  const duplicates = React.useMemo(
    () => findDuplicates(tableArray),
    [tableArray]
  );
  const newRecordsCount = React.useMemo(() => {
    const currentSameAsDb = compareWithDb(tableArray, currentDbState);
    if (currentSameAsDb) {
      return 0;
    } else {
      return Math.max(
        0,
        tableArray.length - currentDbState.length - duplicates.count
      );
    }
  }, [tableArray, currentDbState, duplicates]);

  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    if (!e.target.files || e.target.files.length === 0) return;
    const inputFile = e.target.files[0];
    if (inputFile.type === "text/plain") {
      inputFile
        .text()
        .then((txt) => validateTxtFileFormat(txt))
        .then(() => {
          setError(null);
          setFile(inputFile);
        })
        .catch((err) => setError(err.message));
    } else if (
      inputFile.type.includes("application/xml") ||
      inputFile.type.includes("text/xml")
    ) {
      inputFile
        .text()
        .then(() => {
          setError(null);
          setFile(inputFile);
        })
        .catch((err) => setError(err.message));
    } else {
      setError("Invalid file type");
    }
  };

  const handleInputChange =
    (row: number) =>
    (col: number) =>
    (e: React.ChangeEvent<HTMLInputElement>) => {
      let tableArrayCopy = [...tableArray];
      let error = null;

      try {
        validateCell({
          value: e.target.value,
          type: tableArray[row][col].type,
          error: null,
        });
      } catch (err: any) {
        error = err.message as string;
      }

      tableArrayCopy[row][col] = {
        ...tableArray[row][col],
        value: e.target.value,
        error: error,
      };
      setTableArray(tableArrayCopy);
    };

  const handleTxtRead = () => {
    file
      ?.text()
      .then((txt) => {
        const mappedData = mapTxt(txt);
        setTableArray((tableArray) => [...tableArray, ...mappedData]);
      })
      .catch((err) => console.error(err));
  };

  const handleDbRead = async () => {
    try {
      const dbData = await getDbData();
      const parsedDbData = parseDbData(dbData.laptops);
      setTableArray((tableArray) => [...tableArray, ...parsedDbData]);
      setCurrentDbState(parsedDbData);
    } catch (err: any) {
      setError(err.message);
    }
  };

  const handleXmlRead = async () => {
    const parser = new XMLParser({ ignoreAttributes: false });
    const fileContent = await file?.text();
    if (!fileContent) {
      setError("Bad data format");
      return;
    }
    const data = parser.parse(fileContent) as IXMLParsedData;
    setTableArray((tableArray) => [
      ...tableArray,
      ...parseXmlToCellData(data.laptops.laptop),
    ]);
  };

  const saveToDb = async () => {
    const respData = await saveDbData(
      tableArray.filter((_, idx) => !duplicates.duplicates.includes(idx))
    );
  };

  React.useEffect(() => {
    if (!file) return;
    if (file?.type.includes("text/plain")) {
      handleTxtRead();
    } else if (
      file?.type.includes("application/xml") ||
      file?.type.includes("text/xml")
    ) {
      handleXmlRead();
    } else {
      setError("Invalid file format");
    }
  }, [file]);

  const anyErrors = tableArray.reduce(
    (prev, curr) =>
      prev || curr.reduce((pr, cr) => pr || cr.error !== null, false),
    false
  );

  return (
    <>
      <Head>
        <title>Lab04</title>
        <meta name="description" content="Generated by create next app" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <main className={`${styles.main} ${roboto.className}`}>
        <div>
          <div>
            <input type="file" onChange={handleFileChange} />
            <button onClick={handleDbRead}>Import from DB</button>
            {tableArray && tableArray.length > 0 && !anyErrors && (
              <div className={styles.buttons}>
                <button
                  onClick={() =>
                    downloadTxt(joinDataTable(tableArray), `export.txt`)
                  }
                >
                  Export to TXT
                </button>
                <button onClick={() => handleXmlSave(tableArray, `export.xml`)}>
                  Export to XML
                </button>
                <button onClick={saveToDb}>Export to DB</button>
              </div>
            )}
          </div>
          {error && <p className={styles.error}>{error}</p>}
        </div>
        <div>
          <p>Duplicates: {duplicates.count}</p>
          <p>New records: {newRecordsCount}</p>
        </div>
        {tableArray && tableArray.length > 0 && (
          <div className={styles.tabcont}>
            <table className={styles.table}>
              <thead>
                <tr>
                  {headers.map((head) => (
                    <th key={head}>{head}</th>
                  ))}
                </tr>
              </thead>
              <tbody>
                {tableArray.map((line, rowIdx) => (
                  <Row
                    key={rowIdx}
                    values={line}
                    isDuplicate={duplicates.duplicates.includes(rowIdx)}
                    onInputChange={handleInputChange(rowIdx)}
                  />
                ))}
              </tbody>
            </table>
          </div>
        )}
      </main>
    </>
  );
}
